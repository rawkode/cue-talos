// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/rawkode/cue-talos/config/types/v1alpha1

// Package v1alpha1 contains definition of the `v1alpha1` configuration document.
//
// Even though the machine configuration in Talos Linux is multi-document, at the moment
// this configuration document contains most of the configuration options.
//
// It is expected that new configuration options will be added as new documents, and existing ones
// migrated to their own documents.
//
package v1alpha1

// Config defines the v1alpha1.Config Talos machine configuration document.
//
//	examples:
//	   - value: configExample()
//	schemaRoot: true
#Config: {
	//   description: |
	//     Indicates the schema used to decode the contents.
	//   values:
	//     - "v1alpha1"
	version: string @go(ConfigVersion)

	//   description: |
	//     Enable verbose logging to the console.
	//     All system containers logs will flow into serial console.
	//
	//     **Note:** To avoid breaking Talos bootstrap flow enable this option only if serial console can handle high message throughput.
	//   values:
	//     - true
	//     - yes
	//     - false
	//     - no
	debug?: null | bool @go(ConfigDebug,*bool)

	// docgen:nodoc
	//
	// Deprecated: Not supported anymore.
	persist?: null | bool @go(ConfigPersist,*bool)

	//   description: |
	//     Provides machine specific configuration options.
	machine?: null | #MachineConfig @go(MachineConfig,*MachineConfig)

	//   description: |
	//     Provides cluster specific configuration options.
	cluster?: null | #ClusterConfig @go(ClusterConfig,*ClusterConfig)
}

// MachineConfig represents the machine-specific config values.
//
//	examples:
//	   - value: machineConfigExample()
#MachineConfig: {
	//   description: |
	//     Defines the role of the machine within the cluster.
	//
	//     **Control Plane**
	//
	//     Control Plane node type designates the node as a control plane member.
	//     This means it will host etcd along with the Kubernetes controlplane components such as API Server, Controller Manager, Scheduler.
	//
	//     **Worker**
	//
	//     Worker node type designates the node as a worker node.
	//     This means it will be an available compute node for scheduling workloads.
	//
	//     This node type was previously known as "join"; that value is still supported but deprecated.
	//   values:
	//     - "controlplane"
	//     - "worker"
	type: string @go(MachineType)

	//   description: |
	//     The `token` is used by a machine to join the PKI of the cluster.
	//     Using this token, a machine will create a certificate signing request (CSR), and request a certificate that will be used as its' identity.
	//   examples:
	//     - name: example token
	//       value: "\"328hom.uqjzh6jnn2eie9oi\""
	token: string @go(MachineToken)

	//   description: |
	//     Extra certificate subject alternative names for the machine's certificate.
	//     By default, all non-loopback interface IPs are automatically added to the certificate's SANs.
	//   examples:
	//     - name: Uncomment this to enable SANs.
	//       value: '[]string{"10.0.0.10", "172.16.0.10", "192.168.0.10"}'
	certSANs: [...string] @go(MachineCertSANs,[]string)

	//   description: |
	//     Provides machine specific control plane configuration options.
	//   examples:
	//     - name: ControlPlane definition example.
	//       value: machineControlplaneExample()
	controlPlane?: null | #MachineControlPlaneConfig @go(MachineControlPlane,*MachineControlPlaneConfig)

	//   description: |
	//     Used to provide additional options to the kubelet.
	//   examples:
	//     - name: Kubelet definition example.
	//       value: machineKubeletExample()
	kubelet?: null | #KubeletConfig @go(MachineKubelet,*KubeletConfig)

	//   description: |
	//     Used to provide static pod definitions to be run by the kubelet directly bypassing the kube-apiserver.
	//
	//     Static pods can be used to run components which should be started before the Kubernetes control plane is up.
	//     Talos doesn't validate the pod definition.
	//     Updates to this field can be applied without a reboot.
	//
	//     See https://kubernetes.io/docs/tasks/configure-pod-container/static-pod/.
	//   examples:
	//     - name: nginx static pod.
	//       value: machinePodsExample()
	//   schema:
	//     type: array
	//     items:
	//       type: object
	pods?: [...#Unstructured] @go(MachinePods,[]Unstructured)

	//   description: |
	//     Provides machine specific network configuration options.
	//   examples:
	//     - name: Network definition example.
	//       value: machineNetworkConfigExample()
	network?: null | #NetworkConfig @go(MachineNetwork,*NetworkConfig)

	//   description: |
	//     Used to partition, format and mount additional disks.
	//     Since the rootfs is read only with the exception of `/var`, mounts are only valid if they are under `/var`.
	//     Note that the partitioning and formatting is done only once, if and only if no existing XFS partitions are found.
	//     If `size:` is omitted, the partition is sized to occupy the full disk.
	//   examples:
	//     - name: MachineDisks list example.
	//       value: machineDisksExample()
	disks?: [...null | #MachineDisk] @go(MachineDisks,[]*MachineDisk)

	//   description: |
	//     Used to provide instructions for installations.
	//
	//     Note that this configuration section gets silently ignored by Talos images that are considered pre-installed.
	//     To make sure Talos installs according to the provided configuration, Talos should be booted with ISO or PXE-booted.
	//   examples:
	//     - name: MachineInstall config usage example.
	//       value: machineInstallExample()
	install?: null | #InstallConfig @go(MachineInstall,*InstallConfig)

	//   description: |
	//     Allows the addition of user specified files.
	//     The value of `op` can be `create`, `overwrite`, or `append`.
	//     In the case of `create`, `path` must not exist.
	//     In the case of `overwrite`, and `append`, `path` must be a valid file.
	//     If an `op` value of `append` is used, the existing file will be appended.
	//     Note that the file contents are not required to be base64 encoded.
	//   examples:
	//      - name: MachineFiles usage example.
	//        value: machineFilesExample()
	files?: [...null | #MachineFile] @go(MachineFiles,[]*MachineFile)

	//   description: |
	//     The `env` field allows for the addition of environment variables.
	//     All environment variables are set on PID 1 in addition to every service.
	//   values:
	//     - "`GRPC_GO_LOG_VERBOSITY_LEVEL`"
	//     - "`GRPC_GO_LOG_SEVERITY_LEVEL`"
	//     - "`http_proxy`"
	//     - "`https_proxy`"
	//     - "`no_proxy`"
	//   examples:
	//     - name: Environment variables definition examples.
	//       value: machineEnvExamples0()
	//     - value: machineEnvExamples1()
	//     - value: machineEnvExamples2()
	//   schema:
	//     type: object
	//     patternProperties:
	//       ".*":
	//         type: string
	env?: {[string]: string} @go(MachineEnv,map[string]string)

	//   description: |
	//     Used to configure the machine's time settings.
	//   examples:
	//     - name: Example configuration for cloudflare ntp server.
	//       value: machineTimeExample()
	time?: null | #TimeConfig @go(MachineTime,*TimeConfig)

	//   description: |
	//     Used to configure the machine's sysctls.
	//   examples:
	//     - name: MachineSysctls usage example.
	//       value: machineSysctlsExample()
	sysctls?: {[string]: string} @go(MachineSysctls,map[string]string)

	//   description: |
	//     Used to configure the machine's sysfs.
	//   examples:
	//     - name: MachineSysfs usage example.
	//       value: machineSysfsExample()
	sysfs?: {[string]: string} @go(MachineSysfs,map[string]string)

	//   description: |
	//     Used to configure the machine's container image registry mirrors.
	//
	//     Automatically generates matching CRI configuration for registry mirrors.
	//
	//     The `mirrors` section allows to redirect requests for images to a non-default registry,
	//     which might be a local registry or a caching mirror.
	//
	//     The `config` section provides a way to authenticate to the registry with TLS client
	//     identity, provide registry CA, or authentication information.
	//     Authentication information has same meaning with the corresponding field in [`.docker/config.json`](https://docs.docker.com/engine/api/v1.41/#section/Authentication).
	//
	//     See also matching configuration for [CRI containerd plugin](https://github.com/containerd/cri/blob/master/docs/registry.md).
	//   examples:
	//     - value: machineConfigRegistriesExample()
	registries?: #RegistriesConfig @go(MachineRegistries)

	//   description: |
	//     Machine system disk encryption configuration.
	//     Defines each system partition encryption parameters.
	//   examples:
	//     - value: machineSystemDiskEncryptionExample()
	systemDiskEncryption?: null | #SystemDiskEncryptionConfig @go(MachineSystemDiskEncryption,*SystemDiskEncryptionConfig)

	//   description: |
	//     Features describe individual Talos features that can be switched on or off.
	//   examples:
	//     - value: machineFeaturesExample()
	features?: null | #FeaturesConfig @go(MachineFeatures,*FeaturesConfig)

	//   description: |
	//     Configures the udev system.
	//   examples:
	//     - value: machineUdevExample()
	udev?: null | #UdevConfig @go(MachineUdev,*UdevConfig)

	//   description: |
	//     Configures the logging system.
	//   examples:
	//     - value: machineLoggingExample()
	logging?: null | #LoggingConfig @go(MachineLogging,*LoggingConfig)

	//   description: |
	//     Configures the kernel.
	//   examples:
	//     - value: machineKernelExample()
	kernel?: null | #KernelConfig @go(MachineKernel,*KernelConfig)

	//  description: |
	//    Configures the seccomp profiles for the machine.
	//  examples:
	//    - value: machineSeccompExample()
	seccompProfiles?: [...null | #MachineSeccompProfile] @go(MachineSeccompProfiles,[]*MachineSeccompProfile)

	//  description: |
	//    Configures the node labels for the machine.
	//
	//    Note: In the default Kubernetes configuration, worker nodes are restricted to set
	//    labels with some prefixes (see [NodeRestriction](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction) admission plugin).
	//  examples:
	//    - name: node labels example.
	//      value: 'map[string]string{"exampleLabel": "exampleLabelValue"}'
	nodeLabels?: {[string]: string} @go(MachineNodeLabels,map[string]string)

	//  description: |
	//    Configures the node taints for the machine. Effect is optional.
	//
	//    Note: In the default Kubernetes configuration, worker nodes are not allowed to
	//    modify the taints (see [NodeRestriction](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction) admission plugin).
	//  examples:
	//    - name: node taints example.
	//      value: 'map[string]string{"exampleTaint": "exampleTaintValue:NoSchedule"}'
	nodeTaints?: {[string]: string} @go(MachineNodeTaints,map[string]string)
}

// MachineSeccompProfile defines seccomp profiles for the machine.
#MachineSeccompProfile: {
	//  description: |
	//    The `name` field is used to provide the file name of the seccomp profile.
	name: string @go(MachineSeccompProfileName)

	// description: |
	//   The `value` field is used to provide the seccomp profile.
	// schema:
	//   type: object
	value: #Unstructured @go(MachineSeccompProfileValue)
}

// ClusterConfig represents the cluster-wide config values.
//
//	examples:
//	   - value: clusterConfigExample()
#ClusterConfig: {
	//   description: |
	//     Globally unique identifier for this cluster (base64 encoded random 32 bytes).
	id?: string @go(ClusterID)

	//   description: |
	//     Shared secret of cluster (base64 encoded random 32 bytes).
	//     This secret is shared among cluster members but should never be sent over the network.
	secret?: string @go(ClusterSecret)

	//   description: |
	//     Provides control plane specific configuration options.
	//   examples:
	//     - name: Setting controlplane endpoint address to 1.2.3.4 and port to 443 example.
	//       value: clusterControlPlaneExample()
	controlPlane?: null | #ControlPlaneConfig @go(ControlPlane,*ControlPlaneConfig)

	//   description: |
	//     Configures the cluster's name.
	clusterName?: string @go(ClusterName)

	//   description: |
	//     Provides cluster specific network configuration options.
	//   examples:
	//     - name: Configuring with flannel CNI and setting up subnets.
	//       value:  clusterNetworkExample()
	network?: null | #ClusterNetworkConfig @go(ClusterNetwork,*ClusterNetworkConfig)

	//   description: |
	//     The [bootstrap token](https://kubernetes.io/docs/reference/access-authn-authz/bootstrap-tokens/) used to join the cluster.
	//   examples:
	//     - name: Bootstrap token example (do not use in production!).
	//       value: '"wlzjyw.bei2zfylhs2by0wd"'
	token?: string @go(BootstrapToken)

	//   description: |
	//     A key used for the [encryption of secret data at rest](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/).
	//     Enables encryption with AESCBC.
	//   examples:
	//     - name: Decryption secret example (do not use in production!).
	//       value: '"z01mye6j16bspJYtTB/5SFX8j7Ph4JXxM2Xuu4vsBPM="'
	aescbcEncryptionSecret?: string @go(ClusterAESCBCEncryptionSecret)

	//   description: |
	//     A key used for the [encryption of secret data at rest](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/).
	//     Enables encryption with secretbox.
	//     Secretbox has precedence over AESCBC.
	//   examples:
	//     - name: Decryption secret example (do not use in production!).
	//       value: '"z01mye6j16bspJYtTB/5SFX8j7Ph4JXxM2Xuu4vsBPM="'
	secretboxEncryptionSecret?: string @go(ClusterSecretboxEncryptionSecret)

	//   description: |
	//     API server specific configuration options.
	//   examples:
	//     - value: clusterAPIServerExample()
	apiServer?: null | #APIServerConfig @go(APIServerConfig,*APIServerConfig)

	//   description: |
	//     Controller manager server specific configuration options.
	//   examples:
	//     - value: clusterControllerManagerExample()
	controllerManager?: null | #ControllerManagerConfig @go(ControllerManagerConfig,*ControllerManagerConfig)

	//   description: |
	//     Kube-proxy server-specific configuration options
	//   examples:
	//     - value: clusterProxyExample()
	proxy?: null | #ProxyConfig @go(ProxyConfig,*ProxyConfig)

	//   description: |
	//     Scheduler server specific configuration options.
	//   examples:
	//     - value: clusterSchedulerExample()
	scheduler?: null | #SchedulerConfig @go(SchedulerConfig,*SchedulerConfig)

	//   description: |
	//     Configures cluster member discovery.
	//   examples:
	//     - value: clusterDiscoveryExample()
	discovery?: null | #ClusterDiscoveryConfig @go(ClusterDiscoveryConfig,*ClusterDiscoveryConfig)

	//   description: |
	//     Etcd specific configuration options.
	//   examples:
	//     - value: clusterEtcdExample()
	etcd?: null | #EtcdConfig @go(EtcdConfig,*EtcdConfig)

	//   description: |
	//     Core DNS specific configuration options.
	//   examples:
	//     - value: clusterCoreDNSExample()
	coreDNS?: null | #CoreDNS @go(CoreDNSConfig,*CoreDNS)

	//   description: |
	//     External cloud provider configuration.
	//   examples:
	//     - value: clusterExternalCloudProviderConfigExample()
	externalCloudProvider?: null | #ExternalCloudProviderConfig @go(ExternalCloudProviderConfig,*ExternalCloudProviderConfig)

	//   description: |
	//     A list of urls that point to additional manifests.
	//     These will get automatically deployed as part of the bootstrap.
	//   examples:
	//     - value: >
	//        []string{
	//         "https://www.example.com/manifest1.yaml",
	//         "https://www.example.com/manifest2.yaml",
	//        }
	extraManifests?: [...string] @go(ExtraManifests,[]string)

	//   description: |
	//     A map of key value pairs that will be added while fetching the extraManifests.
	//   examples:
	//     - value: >
	//         map[string]string{
	//           "Token": "1234567",
	//           "X-ExtraInfo": "info",
	//         }
	extraManifestHeaders?: {[string]: string} @go(ExtraManifestHeaders,map[string]string)

	//   description: |
	//     A list of inline Kubernetes manifests.
	//     These will get automatically deployed as part of the bootstrap.
	//   examples:
	//     - value: clusterInlineManifestsExample()
	//   schema:
	//     type: array
	//     items:
	//       $ref: "#/$defs/v1alpha1.ClusterInlineManifest"
	inlineManifests?: #ClusterInlineManifests @go(ClusterInlineManifests)

	//   description: |
	//     Settings for admin kubeconfig generation.
	//     Certificate lifetime can be configured.
	//   examples:
	//     - value: clusterAdminKubeconfigExample()
	adminKubeconfig?: null | #AdminKubeconfigConfig @go(AdminKubeconfigConfig,*AdminKubeconfigConfig)

	// docgen:nodoc
	//
	// Deprecated: Use `AllowSchedulingOnControlPlanes` instead.
	allowSchedulingOnMasters?: null | bool @go(AllowSchedulingOnMasters,*bool)

	//   description: |
	//     Allows running workload on control-plane nodes.
	//   values:
	//     - true
	//     - yes
	//     - false
	//     - no
	//   examples:
	//     - value: true
	allowSchedulingOnControlPlanes?: null | bool @go(AllowSchedulingOnControlPlanes,*bool)
}

// LinuxIDMapping represents the Linux ID mapping.
#LinuxIDMapping: {
	//   description: |
	//     ContainerID is the starting UID/GID in the container.
	containerID: uint32 @go(ContainerID)

	//   description: |
	//     HostID is the starting UID/GID on the host to be mapped to 'ContainerID'.
	hostID: uint32 @go(HostID)

	//   description: |
	//     Size is the number of IDs to be mapped.
	size: uint32 @go(Size)
}

// ExtraMount wraps OCI Mount specification.
#ExtraMount: {
	//   description: |
	//     Destination is the absolute path where the mount will be placed in the container.
	destination: string @go(Destination)

	//   description: |
	//     Type specifies the mount kind.
	type?: string @go(Type)

	//   description: |
	//     Source specifies the source path of the mount.
	source?: string @go(Source)

	//   description: |
	//     Options are fstab style mount options.
	options?: [...string] @go(Options,[]string)

	//   description: |
	//     UID/GID mappings used for changing file owners w/o calling chown, fs should support it.
	//
	//     Every mount point could have its own mapping.
	uidMappings?: [...#LinuxIDMapping] @go(UIDMappings,[]LinuxIDMapping)

	//   description: |
	//     UID/GID mappings used for changing file owners w/o calling chown, fs should support it.
	//
	//     Every mount point could have its own mapping.
	gidMappings?: [...#LinuxIDMapping] @go(GIDMappings,[]LinuxIDMapping)
}

// MachineControlPlaneConfig machine specific configuration options.
#MachineControlPlaneConfig: {
	//   description: |
	//     Controller manager machine specific configuration options.
	controllerManager?: null | #MachineControllerManagerConfig @go(MachineControllerManager,*MachineControllerManagerConfig)

	//   description: |
	//     Scheduler machine specific configuration options.
	scheduler?: null | #MachineSchedulerConfig @go(MachineScheduler,*MachineSchedulerConfig)
}

// MachineControllerManagerConfig represents the machine specific ControllerManager config values.
#MachineControllerManagerConfig: {
	//   description: |
	//     Disable kube-controller-manager on the node.
	disabled?: null | bool @go(MachineControllerManagerDisabled,*bool)
}

// MachineSchedulerConfig represents the machine specific Scheduler config values.
#MachineSchedulerConfig: {
	//   description: |
	//     Disable kube-scheduler on the node.
	disabled?: null | bool @go(MachineSchedulerDisabled,*bool)
}

// KubeletConfig represents the kubelet config values.
#KubeletConfig: {
	//   description: |
	//     The `image` field is an optional reference to an alternative kubelet image.
	//   examples:
	//     - value: kubeletImageExample()
	image?: string @go(KubeletImage)

	//   description: |
	//     The `ClusterDNS` field is an optional reference to an alternative kubelet clusterDNS ip list.
	//   examples:
	//     - value: '[]string{"10.96.0.10", "169.254.2.53"}'
	clusterDNS?: [...string] @go(KubeletClusterDNS,[]string)

	//   description: |
	//     The `extraArgs` field is used to provide additional flags to the kubelet.
	//   examples:
	//     - value: >
	//         map[string]string{
	//           "key": "value",
	//         }
	extraArgs?: {[string]: string} @go(KubeletExtraArgs,map[string]string)

	//   description: |
	//     The `extraMounts` field is used to add additional mounts to the kubelet container.
	//     Note that either `bind` or `rbind` are required in the `options`.
	//   examples:
	//     - value: kubeletExtraMountsExample()
	extraMounts?: [...#ExtraMount] @go(KubeletExtraMounts,[]ExtraMount)

	//   description: |
	//     The `extraConfig` field is used to provide kubelet configuration overrides.
	//
	//     Some fields are not allowed to be overridden: authentication and authorization, cgroups
	//     configuration, ports, etc.
	//   examples:
	//     - value: kubeletExtraConfigExample()
	//   schema:
	//     type: object
	extraConfig?: #Unstructured @go(KubeletExtraConfig)

	//  description: |
	//   The `KubeletCredentialProviderConfig` field is used to provide kubelet credential configuration.
	//  examples:
	//    - value: kubeletCredentialProviderConfigExample()
	//  schema:
	//    type: object
	credentialProviderConfig?: #Unstructured @go(KubeletCredentialProviderConfig)

	//  description: |
	//    Enable container runtime default Seccomp profile.
	//  values:
	//    - true
	//    - yes
	//    - false
	//    - no
	defaultRuntimeSeccompProfileEnabled?: null | bool @go(KubeletDefaultRuntimeSeccompProfileEnabled,*bool)

	//   description: |
	//     The `registerWithFQDN` field is used to force kubelet to use the node FQDN for registration.
	//     This is required in clouds like AWS.
	//   values:
	//     - true
	//     - yes
	//     - false
	//     - no
	registerWithFQDN?: null | bool @go(KubeletRegisterWithFQDN,*bool)

	//   description: |
	//     The `nodeIP` field is used to configure `--node-ip` flag for the kubelet.
	//     This is used when a node has multiple addresses to choose from.
	//   examples:
	//     - value: kubeletNodeIPExample()
	nodeIP?: null | #KubeletNodeIPConfig @go(KubeletNodeIP,*KubeletNodeIPConfig)

	//   description: |
	//      The `skipNodeRegistration` is used to run the kubelet without registering with the apiserver.
	//      This runs kubelet as standalone and only runs static pods.
	//   values:
	//     - true
	//     - yes
	//     - false
	//     - no
	skipNodeRegistration?: null | bool @go(KubeletSkipNodeRegistration,*bool)

	//   description: |
	//     The `disableManifestsDirectory` field configures the kubelet to get static pod manifests from the /etc/kubernetes/manifests directory.
	//     It's recommended to configure static pods with the "pods" key instead.
	//   values:
	//     - true
	//     - yes
	//     - false
	//     - no
	disableManifestsDirectory?: null | bool @go(KubeletDisableManifestsDirectory,*bool)
}

// KubeletNodeIPConfig represents the kubelet node IP configuration.
#KubeletNodeIPConfig: {
	//  description: |
	//    The `validSubnets` field configures the networks to pick kubelet node IP from.
	//    For dual stack configuration, there should be two subnets: one for IPv4, another for IPv6.
	//    IPs can be excluded from the list by using negative match with `!`, e.g `!10.0.0.0/8`.
	//    Negative subnet matches should be specified last to filter out IPs picked by positive matches.
	//    If not specified, node IP is picked based on cluster podCIDRs: IPv4/IPv6 address or both.
	validSubnets?: [...string] @go(KubeletNodeIPValidSubnets,[]string)
}

// NetworkConfig represents the machine's networking config values.
#NetworkConfig: {
	//   description: |
	//     Used to statically set the hostname for the machine.
	hostname?: string @go(NetworkHostname)

	//   description: |
	//     `interfaces` is used to define the network interface configuration.
	//     By default all network interfaces will attempt a DHCP discovery.
	//     This can be further tuned through this configuration parameter.
	//   examples:
	//     - value: machineNetworkConfigExample().NetworkInterfaces
	interfaces?: #NetworkDeviceList @go(NetworkInterfaces)

	//   description: |
	//     Used to statically set the nameservers for the machine.
	//     Defaults to `1.1.1.1` and `8.8.8.8`
	//   examples:
	//     - value: '[]string{"8.8.8.8", "1.1.1.1"}'
	nameservers?: [...string] @go(NameServers,[]string)

	//   description: |
	//     Allows for extra entries to be added to the `/etc/hosts` file
	//   examples:
	//     - value: networkConfigExtraHostsExample()
	extraHostEntries?: [...null | #ExtraHost] @go(ExtraHostEntries,[]*ExtraHost)

	//   description: |
	//     Configures KubeSpan feature.
	//   examples:
	//     - value: networkKubeSpanExample()
	kubespan?: null | #NetworkKubeSpan @go(NetworkKubeSpan,*NetworkKubeSpan)

	//   description: |
	//     Disable generating a default search domain in /etc/resolv.conf
	//     based on the machine hostname.
	//     Defaults to `false`.
	//   values:
	//     - true
	//     - yes
	//     - false
	//     - no
	disableSearchDomain?: null | bool @go(NetworkDisableSearchDomain,*bool)
}

// NetworkDeviceList is a list of *Device structures with overridden merge process.
//
//docgen:alias
#NetworkDeviceList: [...null | #Device]

// InstallConfig represents the installation options for preparing a node.
#InstallConfig: {
	//   description: |
	//     The disk used for installations.
	//   examples:
	//     - value: '"/dev/sda"'
	//     - value: '"/dev/nvme0"'
	disk?: string @go(InstallDisk)

	//   description: |
	//     Look up disk using disk attributes like model, size, serial and others.
	//     Always has priority over `disk`.
	//   examples:
	//     - value: machineInstallDiskSelectorExample()
	diskSelector?: null | #InstallDiskSelector @go(InstallDiskSelector,*InstallDiskSelector)

	//   description: |
	//     Allows for supplying extra kernel args via the bootloader.
	//     Existing kernel args can be removed by prefixing the argument with a `-`.
	//     For example `-console` removes all `console=<value>` arguments, whereas `-console=tty0` removes the `console=tty0` default argument.
	//   examples:
	//     - value: '[]string{"talos.platform=metal", "reboot=k"}'
	extraKernelArgs?: [...string] @go(InstallExtraKernelArgs,[]string)

	//   description: |
	//     Allows for supplying the image used to perform the installation.
	//     Image reference for each Talos release can be found on
	//     [GitHub releases page](https://github.com/siderolabs/talos/releases).
	//   examples:
	//     - value: '"ghcr.io/siderolabs/installer:latest"'
	image?: string @go(InstallImage)

	//   description: |
	//     Allows for supplying additional system extension images to install on top of base Talos image.
	//   examples:
	//     - value: installExtensionsExample()
	extensions?: [...#InstallExtensionConfig] @go(InstallExtensions,[]InstallExtensionConfig)

	// docgen:nodoc
	//
	// Deprecated: It never worked.
	bootloader?: null | bool @go(InstallBootloader,*bool)

	//   description: |
	//     Indicates if the installation disk should be wiped at installation time.
	//     Defaults to `true`.
	//   values:
	//     - true
	//     - yes
	//     - false
	//     - no
	wipe?: null | bool @go(InstallWipe,*bool)

	//   description: |
	//     Indicates if MBR partition should be marked as bootable (active).
	//     Should be enabled only for the systems with legacy BIOS that doesn't support GPT partitioning scheme.
	legacyBIOSSupport?: null | bool @go(InstallLegacyBIOSSupport,*bool)
}

// InstallDiskSizeMatcher disk size condition parser.
// docgen:nodoc
#InstallDiskSizeMatcher: _

// InstallDiskSizeMatchData contains data for comparison - Op and Size.
//
//docgen:nodoc
#InstallDiskSizeMatchData: {
	Op:   string
	Size: uint64
}

// InstallDiskSelector represents a disk query parameters for the install disk lookup.
#InstallDiskSelector: {
	//   description: Disk size.
	//   examples:
	//     - name: Select a disk which size is equal to 4GB.
	//       value: machineInstallDiskSizeMatcherExamples0()
	//     - name: Select a disk which size is greater than 1TB.
	//       value: machineInstallDiskSizeMatcherExamples1()
	//     - name: Select a disk which size is less or equal than 2TB.
	//       value: machineInstallDiskSizeMatcherExamples2()
	//   schema:
	//     type: string
	size?: null | #InstallDiskSizeMatcher @go(Size,*InstallDiskSizeMatcher)

	//   description: Disk name `/sys/block/<dev>/device/name`.
	name?: string @go(Name)

	//   description: Disk model `/sys/block/<dev>/device/model`.
	model?: string @go(Model)

	//   description: Disk serial number `/sys/block/<dev>/serial`.
	serial?: string @go(Serial)

	//   description: Disk modalias `/sys/block/<dev>/device/modalias`.
	modalias?: string @go(Modalias)

	//   description: Disk UUID `/sys/block/<dev>/uuid`.
	uuid?: string @go(UUID)

	//   description: Disk WWID `/sys/block/<dev>/wwid`.
	wwid?: string @go(WWID)

	//   description: Disk bus path.
	//   examples:
	//     - value: '"/pci0000:00/0000:00:17.0/ata1/host0/target0:0:0/0:0:0:0"'
	//     - value: '"/pci0000:00/*"'
	busPath?: string @go(BusPath)
}

// InstallExtensionConfig represents a configuration for a system extension.
#InstallExtensionConfig: {
	//   description: System extension image.
	image: string @go(ExtensionImage)
}

// TimeConfig represents the options for configuring time on a machine.
#TimeConfig: {
	//   description: |
	//     Indicates if the time service is disabled for the machine.
	//     Defaults to `false`.
	disabled?: null | bool @go(TimeDisabled,*bool)

	//   description: |
	//     Specifies time (NTP) servers to use for setting the system time.
	//     Defaults to `time.cloudflare.com`.
	//
	//	   Talos can also sync to the PTP time source (e.g provided by the hypervisor),
	//     provide the path to the PTP device as "/dev/ptp0" or "/dev/ptp_kvm".
	servers?: [...string] @go(TimeServers,[]string)

	//   description: |
	//     Specifies the timeout when the node time is considered to be in sync unlocking the boot sequence.
	//     NTP sync will be still running in the background.
	//     Defaults to "infinity" (waiting forever for time sync)
	//   schema:
	//     type: string
	//     pattern: ^[-+]?(((\d+(\.\d*)?|\d*(\.\d+)+)([nuµm]?s|m|h))|0)+$
	bootTimeout?: int @go(TimeBootTimeout,time.Duration)
}

// RegistriesConfig represents the image pull options.
#RegistriesConfig: {
	//   description: |
	//     Specifies mirror configuration for each registry host namespace.
	//     This setting allows to configure local pull-through caching registires,
	//     air-gapped installations, etc.
	//
	//     For example, when pulling an image with the reference `example.com:123/image:v1`,
	//     the `example.com:123` key will be used to lookup the mirror configuration.
	//
	//     Optionally the `*` key can be used to configure a fallback mirror.
	//
	//     Registry name is the first segment of image identifier, with 'docker.io'
	//     being default one.
	//   examples:
	//     - value: machineConfigRegistryMirrorsExample()
	mirrors?: {[string]: null | #RegistryMirrorConfig} @go(RegistryMirrors,map[string]*RegistryMirrorConfig)

	//   description: |
	//     Specifies TLS & auth configuration for HTTPS image registries.
	//     Mutual TLS can be enabled with 'clientIdentity' option.
	//
	//     The full hostname and port (if not using a default port 443)
	//     should be used as the key.
	//     The fallback key `*` can't be used for TLS configuration.
	//
	//     TLS configuration can be skipped if registry has trusted
	//     server certificate.
	//   examples:
	//     - value: machineConfigRegistryConfigExample()
	config?: {[string]: null | #RegistryConfig} @go(RegistryConfig,map[string]*RegistryConfig)
}

// PodCheckpointer represents the pod-checkpointer config values.
//
//docgen:nodoc
#PodCheckpointer: {
	//   description: |
	//     The `image` field is an override to the default pod-checkpointer image.
	image?: string @go(PodCheckpointerImage)
}

// CoreDNS represents the CoreDNS config values.
#CoreDNS: {
	//   description: |
	//     Disable coredns deployment on cluster bootstrap.
	disabled?: null | bool @go(CoreDNSDisabled,*bool)

	//   description: |
	//     The `image` field is an override to the default coredns image.
	image?: string @go(CoreDNSImage)
}

// Endpoint represents the endpoint URL parsed out of the machine config.
#Endpoint: _

// ControlPlaneConfig represents the control plane configuration options.
#ControlPlaneConfig: {
	//   description: |
	//     Endpoint is the canonical controlplane endpoint, which can be an IP address or a DNS hostname.
	//     It is single-valued, and may optionally include a port number.
	//   examples:
	//     - value: clusterEndpointExample1()
	//     - value: clusterEndpointExample2()
	//   schema:
	//     type: string
	//     format: uri
	//     pattern: "^https://"
	endpoint?: null | #Endpoint @go(Endpoint,*Endpoint)

	//   description: |
	//     The port that the API server listens on internally.
	//     This may be different than the port portion listed in the endpoint field above.
	//     The default is `6443`.
	localAPIServerPort?: int @go(LocalAPIServerPort)
}

// APIServerConfig represents the kube apiserver configuration options.
#APIServerConfig: {
	//   description: |
	//     The container image used in the API server manifest.
	//   examples:
	//     - value: clusterAPIServerImageExample()
	image?: string @go(ContainerImage)

	//   description: |
	//     Extra arguments to supply to the API server.
	extraArgs?: {[string]: string} @go(ExtraArgsConfig,map[string]string)

	//   description: |
	//     Extra volumes to mount to the API server static pod.
	extraVolumes?: [...#VolumeMountConfig] @go(ExtraVolumesConfig,[]VolumeMountConfig)

	//   description: |
	//     The `env` field allows for the addition of environment variables for the control plane component.
	//   schema:
	//     type: object
	//     patternProperties:
	//       ".*":
	//         type: string
	env?: {[string]: string} @go(EnvConfig,map[string]string)

	//   description: |
	//     Extra certificate subject alternative names for the API server's certificate.
	certSANs?: [...string] @go(CertSANs,[]string)

	//   description: |
	//     Disable PodSecurityPolicy in the API server and default manifests.
	disablePodSecurityPolicy?: null | bool @go(DisablePodSecurityPolicyConfig,*bool)

	//   description: |
	//     Configure the API server admission plugins.
	//   examples:
	//     - value: admissionControlConfigExample()
	admissionControl?: #AdmissionPluginConfigList @go(AdmissionControlConfig)

	//   description: |
	//     Configure the API server audit policy.
	//   examples:
	//     - value: APIServerDefaultAuditPolicy
	//   schema:
	//     type: object
	auditPolicy?: #Unstructured @go(AuditPolicyConfig)

	//   description: |
	//     Configure the API server resources.
	//   schema:
	//     type: object
	resources?: null | #ResourcesConfig @go(ResourcesConfig,*ResourcesConfig)
}

// AdmissionPluginConfigList represents the admission plugin configuration list.
//
//docgen:alias
#AdmissionPluginConfigList: [...null | #AdmissionPluginConfig]

// AdmissionPluginConfig represents the API server admission plugin configuration.
#AdmissionPluginConfig: {
	//   description: |
	//     Name is the name of the admission controller.
	//     It must match the registered admission plugin name.
	name: string @go(PluginName)

	//   description: |
	//     Configuration is an embedded configuration object to be used as the plugin's
	//     configuration.
	//   schema:
	//     type: object
	configuration: #Unstructured @go(PluginConfiguration)
}

// ControllerManagerConfig represents the kube controller manager configuration options.
#ControllerManagerConfig: {
	//   description: |
	//     The container image used in the controller manager manifest.
	//   examples:
	//     - value: clusterControllerManagerImageExample()
	image?: string @go(ContainerImage)

	//   description: |
	//     Extra arguments to supply to the controller manager.
	extraArgs?: {[string]: string} @go(ExtraArgsConfig,map[string]string)

	//   description: |
	//     Extra volumes to mount to the controller manager static pod.
	extraVolumes?: [...#VolumeMountConfig] @go(ExtraVolumesConfig,[]VolumeMountConfig)

	//   description: |
	//     The `env` field allows for the addition of environment variables for the control plane component.
	//   schema:
	//     type: object
	//     patternProperties:
	//       ".*":
	//         type: string
	env?: {[string]: string} @go(EnvConfig,map[string]string)

	//   description: |
	//     Configure the controller manager resources.
	//   schema:
	//     type: object
	resources?: null | #ResourcesConfig @go(ResourcesConfig,*ResourcesConfig)
}

// ProxyConfig represents the kube proxy configuration options.
#ProxyConfig: {
	//   description: |
	//     Disable kube-proxy deployment on cluster bootstrap.
	//   examples:
	//     - value: pointer.To(false)
	disabled?: null | bool @go(Disabled,*bool)

	//   description: |
	//     The container image used in the kube-proxy manifest.
	//   examples:
	//     - value: clusterProxyImageExample()
	image?: string @go(ContainerImage)

	//   description: |
	//     proxy mode of kube-proxy.
	//     The default is 'iptables'.
	mode?: string @go(ModeConfig)

	//   description: |
	//     Extra arguments to supply to kube-proxy.
	extraArgs?: {[string]: string} @go(ExtraArgsConfig,map[string]string)
}

// SchedulerConfig represents the kube scheduler configuration options.
#SchedulerConfig: {
	//   description: |
	//     The container image used in the scheduler manifest.
	//   examples:
	//     - value: clusterSchedulerImageExample()
	image?: string @go(ContainerImage)

	//   description: |
	//     Extra arguments to supply to the scheduler.
	extraArgs?: {[string]: string} @go(ExtraArgsConfig,map[string]string)

	//   description: |
	//     Extra volumes to mount to the scheduler static pod.
	extraVolumes?: [...#VolumeMountConfig] @go(ExtraVolumesConfig,[]VolumeMountConfig)

	//   description: |
	//     The `env` field allows for the addition of environment variables for the control plane component.
	//   schema:
	//     type: object
	//     patternProperties:
	//       ".*":
	//         type: string
	env?: {[string]: string} @go(EnvConfig,map[string]string)

	//   description: |
	//     Configure the scheduler resources.
	//   schema:
	//     type: object
	resources?: null | #ResourcesConfig @go(ResourcesConfig,*ResourcesConfig)

	//   description: |
	//     Specify custom kube-scheduler configuration.
	//   schema:
	//     type: object
	config?: #Unstructured @go(SchedulerConfig)
}

// EtcdConfig represents the etcd configuration options.
#EtcdConfig: {
	//   description: |
	//     The container image used to create the etcd service.
	//   examples:
	//     - value: clusterEtcdImageExample()
	image?: string @go(ContainerImage)

	//   description: |
	//     Extra arguments to supply to etcd.
	//     Note that the following args are not allowed:
	//
	//     - `name`
	//     - `data-dir`
	//     - `initial-cluster-state`
	//     - `listen-peer-urls`
	//     - `listen-client-urls`
	//     - `cert-file`
	//     - `key-file`
	//     - `trusted-ca-file`
	//     - `peer-client-cert-auth`
	//     - `peer-cert-file`
	//     - `peer-trusted-ca-file`
	//     - `peer-key-file`
	//   examples:
	//     - values: >
	//         map[string]string{
	//           "initial-cluster": "https://1.2.3.4:2380",
	//           "advertise-client-urls": "https://1.2.3.4:2379",
	//         }
	extraArgs?: {[string]: string} @go(EtcdExtraArgs,map[string]string)

	// docgen:nodoc
	//
	// Deprecated: use EtcdAdvertistedSubnets
	subnet?: string @go(EtcdSubnet)

	//  description: |
	//    The `advertisedSubnets` field configures the networks to pick etcd advertised IP from.
	//
	//    IPs can be excluded from the list by using negative match with `!`, e.g `!10.0.0.0/8`.
	//    Negative subnet matches should be specified last to filter out IPs picked by positive matches.
	//    If not specified, advertised IP is selected as the first routable address of the node.
	//
	//  examples:
	//    - value: clusterEtcdAdvertisedSubnetsExample()
	advertisedSubnets?: [...string] @go(EtcdAdvertisedSubnets,[]string)

	//  description: |
	//    The `listenSubnets` field configures the networks for the etcd to listen for peer and client connections.
	//
	//    If `listenSubnets` is not set, but `advertisedSubnets` is set, `listenSubnets` defaults to
	//    `advertisedSubnets`.
	//
	//    If neither `advertisedSubnets` nor `listenSubnets` is set, `listenSubnets` defaults to listen on all addresses.
	//
	//    IPs can be excluded from the list by using negative match with `!`, e.g `!10.0.0.0/8`.
	//    Negative subnet matches should be specified last to filter out IPs picked by positive matches.
	//    If not specified, advertised IP is selected as the first routable address of the node.
	listenSubnets?: [...string] @go(EtcdListenSubnets,[]string)
}

// ClusterNetworkConfig represents kube networking configuration options.
#ClusterNetworkConfig: {
	//   description: |
	//     The CNI used.
	//     Composed of "name" and "urls".
	//     The "name" key supports the following options: "flannel", "custom", and "none".
	//     "flannel" uses Talos-managed Flannel CNI, and that's the default option.
	//     "custom" uses custom manifests that should be provided in "urls".
	//     "none" indicates that Talos will not manage any CNI installation.
	//   examples:
	//     - value: clusterCustomCNIExample()
	cni?: null | #CNIConfig @go(CNI,*CNIConfig)

	//   description: |
	//     The domain used by Kubernetes DNS.
	//     The default is `cluster.local`
	//   examples:
	//     - value: '"cluser.local"'
	dnsDomain: string @go(DNSDomain)

	//   description: |
	//     The pod subnet CIDR.
	//   examples:
	//     -  value: >
	//          []string{"10.244.0.0/16"}
	podSubnets: [...string] @go(PodSubnet,[]string)

	//   description: |
	//     The service subnet CIDR.
	//   examples:
	//     -  value: >
	//          []string{"10.96.0.0/12"}
	serviceSubnets: [...string] @go(ServiceSubnet,[]string)
}

// CNIConfig represents the CNI configuration options.
#CNIConfig: {
	//   description: |
	//     Name of CNI to use.
	//   values:
	//     - flannel
	//     - custom
	//     - none
	name?: string @go(CNIName)

	//   description: |
	//     URLs containing manifests to apply for the CNI.
	//     Should be present for "custom", must be empty for "flannel" and "none".
	urls?: [...string] @go(CNIUrls,[]string)

	//   description: |
	//		Flannel configuration options.
	flannel?: null | #FlannelCNIConfig @go(CNIFlannel,*FlannelCNIConfig)
}

// FlannelCNIConfig represents the Flannel CNI configuration options.
#FlannelCNIConfig: {
	//   description: |
	//     Extra arguments for 'flanneld'.
	//   examples:
	//     - value: >
	//         []string{"--iface-can-reach=192.168.1.1"}
	extraArgs?: [...string] @go(FlanneldExtraArgs,[]string)
}

// ExternalCloudProviderConfig contains external cloud provider configuration.
#ExternalCloudProviderConfig: {
	//   description: |
	//     Enable external cloud provider.
	//   values:
	//     - true
	//     - yes
	//     - false
	//     - no
	enabled?: null | bool @go(ExternalEnabled,*bool)

	//   description: |
	//     A list of urls that point to additional manifests for an external cloud provider.
	//     These will get automatically deployed as part of the bootstrap.
	//   examples:
	//     - value: >
	//        []string{
	//         "https://raw.githubusercontent.com/kubernetes/cloud-provider-aws/v1.20.0-alpha.0/manifests/rbac.yaml",
	//         "https://raw.githubusercontent.com/kubernetes/cloud-provider-aws/v1.20.0-alpha.0/manifests/aws-cloud-controller-manager-daemonset.yaml",
	//        }
	manifests?: [...string] @go(ExternalManifests,[]string)
}

// AdminKubeconfigConfig contains admin kubeconfig settings.
#AdminKubeconfigConfig: {
	//   description: |
	//     Admin kubeconfig certificate lifetime (default is 1 year).
	//     Field format accepts any Go time.Duration format ('1h' for one hour, '10m' for ten minutes).
	//   schema:
	//     type: string
	//     pattern: ^[-+]?(((\d+(\.\d*)?|\d*(\.\d+)+)([nuµm]?s|m|h))|0)+$
	certLifetime?: int @go(AdminKubeconfigCertLifetime,time.Duration)
}

// MachineDisk represents the options available for partitioning, formatting, and
// mounting extra disks.
#MachineDisk: {
	//   description: The name of the disk to use.
	device?: string @go(DeviceName)

	//   description: A list of partitions to create on the disk.
	partitions?: [...null | #DiskPartition] @go(DiskPartitions,[]*DiskPartition)
}

// DiskSize partition size in bytes.
#DiskSize: _

// DiskPartition represents the options for a disk partition.
#DiskPartition: {
	//   description: >
	//     The size of partition: either bytes or human readable representation. If `size:`
	//     is omitted, the partition is sized to occupy the full disk.
	//   examples:
	//     - name: Human readable representation.
	//       value: DiskSize(100000000)
	//     - name: Precise value in bytes.
	//       value: 1024 * 1024 * 1024
	//   schema:
	//     type: integer
	size?: #DiskSize @go(DiskSize)

	//   description:
	//     Where to mount the partition.
	mountpoint?: string @go(DiskMountPoint)
}

// EncryptionConfig represents partition encryption settings.
#EncryptionConfig: {
	//   description: >
	//     Encryption provider to use for the encryption.
	//   examples:
	//     - value: '"luks2"'
	provider: string @go(EncryptionProvider)

	//   description: >
	//     Defines the encryption keys generation and storage method.
	keys: [...null | #EncryptionKey] @go(EncryptionKeys,[]*EncryptionKey)

	//   description: >
	//     Cipher kind to use for the encryption.
	//     Depends on the encryption provider.
	//   values:
	//     - aes-xts-plain64
	//     - xchacha12,aes-adiantum-plain64
	//     - xchacha20,aes-adiantum-plain64
	//   examples:
	//     - value: '"aes-xts-plain64"'
	cipher?: string @go(EncryptionCipher)

	//   description: >
	//     Defines the encryption key length.
	keySize?: uint @go(EncryptionKeySize)

	//   description: >
	//     Defines the encryption sector size.
	//   examples:
	//     - value: '4096'
	blockSize?: uint64 @go(EncryptionBlockSize)

	//   description: >
	//     Additional --perf parameters for the LUKS2 encryption.
	//   values:
	//     - no_read_workqueue
	//     - no_write_workqueue
	//     - same_cpu_crypt
	//   examples:
	//     -  value: >
	//          []string{"no_read_workqueue","no_write_workqueue"}
	options?: [...string] @go(EncryptionPerfOptions,[]string)
}

// EncryptionKey represents configuration for disk encryption key.
#EncryptionKey: {
	//   description: >
	//     Key which value is stored in the configuration file.
	static?: null | #EncryptionKeyStatic @go(KeyStatic,*EncryptionKeyStatic)

	//   description: >
	//     Deterministically generated key from the node UUID and PartitionLabel.
	nodeID?: null | #EncryptionKeyNodeID @go(KeyNodeID,*EncryptionKeyNodeID)

	//   description: >
	//     KMS managed encryption key.
	//   examples:
	//     - value: kmsKeyExample()
	kms?: null | #EncryptionKeyKMS @go(KeyKMS,*EncryptionKeyKMS)

	//   description: >
	//     Key slot number for LUKS2 encryption.
	slot: int @go(KeySlot)

	//   description: >
	//     Enable TPM based disk encryption.
	tpm?: null | #EncryptionKeyTPM @go(KeyTPM,*EncryptionKeyTPM)
}

// EncryptionKeyStatic represents throw away key type.
#EncryptionKeyStatic: {
	//   description: >
	//     Defines the static passphrase value.
	passphrase?: string @go(KeyData)
}

// EncryptionKeyKMS represents a key that is generated and then sealed/unsealed by the KMS server.
#EncryptionKeyKMS: {
	//   description: >
	//     KMS endpoint to Seal/Unseal the key.
	endpoint: string @go(KMSEndpoint)
}

// EncryptionKeyTPM represents a key that is generated and then sealed/unsealed by the TPM.
#EncryptionKeyTPM: {
	//   description: >
	//     Check that Secureboot is enabled in the EFI firmware.
	//
	//     If Secureboot is not enabled, the enrollment of the key will fail.
	//     As the TPM key is anyways bound to the value of PCR 7,
	//     changing Secureboot status or configuration
	//     after the initial enrollment will make the key unusable.
	checkSecurebootStatusOnEnroll?: null | bool @go(TPMCheckSecurebootStatusOnEnroll,*bool)
}

// EncryptionKeyNodeID represents deterministically generated key from the node UUID and PartitionLabel.
#EncryptionKeyNodeID: {}

// Env represents a set of environment variables.
#Env: {[string]: string}

// ResourcesConfig represents the pod resources.
#ResourcesConfig: {
	//   description: |
	//     Requests configures the reserved cpu/memory resources.
	//   examples:
	//     - name: resources requests.
	//       value: resourcesConfigRequestsExample()
	//   schema:
	//     type: object
	requests?: #Unstructured @go(Requests)

	//   description: |
	//     Limits configures the maximum cpu/memory resources a container can use.
	//   examples:
	//     - name: resources requests.
	//       value: resourcesConfigLimitsExample()
	//   schema:
	//     type: object
	limits?: #Unstructured @go(Limits)
}

// FileMode represents file's permissions.
#FileMode: _

// MachineFile represents a file to write to disk.
#MachineFile: {
	//   description: The contents of the file.
	content: string @go(FileContent)

	//   description: The file's permissions in octal.
	//   schema:
	//     type: integer
	permissions: #FileMode @go(FilePermissions)

	//   description: The path of the file.
	path: string @go(FilePath)

	//   description: The operation to use
	//   values:
	//     - create
	//     - append
	//     - overwrite
	op: string @go(FileOp)
}

// ExtraHost represents a host entry in /etc/hosts.
#ExtraHost: {
	//   description: The IP of the host.
	ip: string @go(HostIP)

	//   description: The host alias.
	aliases: [...string] @go(HostAliases,[]string)
}

// Device represents a network interface.
#Device: {
	//   description: |
	//     The interface name.
	//     Mutually exclusive with `deviceSelector`.
	//   examples:
	//     - value: '"enp0s3"'
	interface?: string @go(DeviceInterface)

	//   description: |
	//     Picks a network device using the selector.
	//     Mutually exclusive with `interface`.
	//     Supports partial match using wildcard syntax.
	//   examples:
	//     - name: select a device with bus prefix 00:*.
	//       value: networkDeviceSelectorExamples()[0]
	//     - name: select a device with mac address matching `*:f0:ab` and `virtio` kernel driver.
	//       value: networkDeviceSelectorExamples()[1]
	deviceSelector?: null | #NetworkDeviceSelector @go(DeviceSelector,*NetworkDeviceSelector)

	//   description: |
	//     Assigns static IP addresses to the interface.
	//     An address can be specified either in proper CIDR notation or as a standalone address (netmask of all ones is assumed).
	//   examples:
	//     - value: '[]string{"10.5.0.0/16", "192.168.3.7"}'
	addresses?: [...string] @go(DeviceAddresses,[]string)

	// docgen:nodoc
	cidr?: string @go(DeviceCIDR)

	//   description: |
	//     A list of routes associated with the interface.
	//     If used in combination with DHCP, these routes will be appended to routes returned by DHCP server.
	//   examples:
	//     - value: networkConfigRoutesExample()
	routes?: [...null | #Route] @go(DeviceRoutes,[]*Route)

	//   description: Bond specific options.
	//   examples:
	//     - value: networkConfigBondExample()
	bond?: null | #Bond @go(DeviceBond,*Bond)

	//   description: Bridge specific options.
	//   examples:
	//     - value: networkConfigBridgeExample()
	bridge?: null | #Bridge @go(DeviceBridge,*Bridge)

	//   description: VLAN specific options.
	vlans?: #VlanList @go(DeviceVlans)

	//   description: |
	//     The interface's MTU.
	//     If used in combination with DHCP, this will override any MTU settings returned from DHCP server.
	mtu?: int @go(DeviceMTU)

	//   description: |
	//     Indicates if DHCP should be used to configure the interface.
	//     The following DHCP options are supported:
	//
	//     - `OptionClasslessStaticRoute`
	//     - `OptionDomainNameServer`
	//     - `OptionDNSDomainSearchList`
	//     - `OptionHostName`
	//
	//   examples:
	//     - value: true
	dhcp?: null | bool @go(DeviceDHCP,*bool)

	//   description: Indicates if the interface should be ignored (skips configuration).
	ignore?: null | bool @go(DeviceIgnore,*bool)

	//   description: |
	//     Indicates if the interface is a dummy interface.
	//     `dummy` is used to specify that this interface should be a virtual-only, dummy interface.
	dummy?: null | bool @go(DeviceDummy,*bool)

	//   description: |
	//     DHCP specific options.
	//     `dhcp` *must* be set to true for these to take effect.
	//   examples:
	//     - value: networkConfigDHCPOptionsExample()
	dhcpOptions?: null | #DHCPOptions @go(DeviceDHCPOptions,*DHCPOptions)

	//   description: |
	//     Wireguard specific configuration.
	//     Includes things like private key, listen port, peers.
	//   examples:
	//     - name: wireguard server example
	//       value: networkConfigWireguardHostExample()
	//     - name: wireguard peer example
	//       value: networkConfigWireguardPeerExample()
	wireguard?: null | #DeviceWireguardConfig @go(DeviceWireguardConfig,*DeviceWireguardConfig)

	//   description: Virtual (shared) IP address configuration.
	//   examples:
	//     - name: layer2 vip example
	//       value: networkConfigVIPLayer2Example()
	vip?: null | #DeviceVIPConfig @go(DeviceVIPConfig,*DeviceVIPConfig)
}

// DHCPOptions contains options for configuring the DHCP settings for a given interface.
#DHCPOptions: {
	//   description: The priority of all routes received via DHCP.
	routeMetric: uint32 @go(DHCPRouteMetric)

	//   description: Enables DHCPv4 protocol for the interface (default is enabled).
	ipv4?: null | bool @go(DHCPIPv4,*bool)

	//   description: Enables DHCPv6 protocol for the interface (default is disabled).
	ipv6?: null | bool @go(DHCPIPv6,*bool)

	//   description: Set client DUID (hex string).
	duidv6?: string @go(DHCPDUIDv6)
}

// DeviceWireguardConfig contains settings for configuring Wireguard network interface.
#DeviceWireguardConfig: {
	//   description: |
	//     Specifies a private key configuration (base64 encoded).
	//     Can be generated by `wg genkey`.
	privateKey?: string @go(WireguardPrivateKey)

	//   description: Specifies a device's listening port.
	listenPort?: int @go(WireguardListenPort)

	//   description: Specifies a device's firewall mark.
	firewallMark?: int @go(WireguardFirewallMark)

	//   description: Specifies a list of peer configurations to apply to a device.
	peers?: [...null | #DeviceWireguardPeer] @go(WireguardPeers,[]*DeviceWireguardPeer)
}

// DeviceWireguardPeer a WireGuard device peer configuration.
#DeviceWireguardPeer: {
	//   description: |
	//     Specifies the public key of this peer.
	//     Can be extracted from private key by running `wg pubkey < private.key > public.key && cat public.key`.
	publicKey?: string @go(WireguardPublicKey)

	//   description: Specifies the endpoint of this peer entry.
	endpoint?: string @go(WireguardEndpoint)

	//   description: |
	//     Specifies the persistent keepalive interval for this peer.
	//     Field format accepts any Go time.Duration format ('1h' for one hour, '10m' for ten minutes).
	//   schema:
	//     type: string
	//     pattern: ^[-+]?(((\d+(\.\d*)?|\d*(\.\d+)+)([nuµm]?s|m|h))|0)+$
	persistentKeepaliveInterval?: int @go(WireguardPersistentKeepaliveInterval,time.Duration)

	//   description: AllowedIPs specifies a list of allowed IP addresses in CIDR notation for this peer.
	allowedIPs?: [...string] @go(WireguardAllowedIPs,[]string)
}

// DeviceVIPConfig contains settings for configuring a Virtual Shared IP on an interface.
#DeviceVIPConfig: {
	// description: Specifies the IP address to be used.
	ip?: string @go(SharedIP)

	// description: Specifies the Equinix Metal API settings to assign VIP to the node.
	equinixMetal?: null | #VIPEquinixMetalConfig @go(EquinixMetalConfig,*VIPEquinixMetalConfig)

	// description: Specifies the Hetzner Cloud API settings to assign VIP to the node.
	hcloud?: null | #VIPHCloudConfig @go(HCloudConfig,*VIPHCloudConfig)
}

// VIPEquinixMetalConfig contains settings for Equinix Metal VIP management.
#VIPEquinixMetalConfig: {
	// description: Specifies the Equinix Metal API Token.
	apiToken: string @go(EquinixMetalAPIToken)
}

// VIPHCloudConfig contains settings for Hetzner Cloud VIP management.
#VIPHCloudConfig: {
	// description: Specifies the Hetzner Cloud API Token.
	apiToken: string @go(HCloudAPIToken)
}

// Bond contains the various options for configuring a bonded interface.
#Bond: {
	//   description: The interfaces that make up the bond.
	interfaces: [...string] @go(BondInterfaces,[]string)

	//   description: |
	//     Picks a network device using the selector.
	//     Mutually exclusive with `interfaces`.
	//     Supports partial match using wildcard syntax.
	//   examples:
	//     - name: select a device with bus prefix 00:*, a device with mac address matching `*:f0:ab` and `virtio` kernel driver.
	//       value: networkDeviceSelectorExamples()
	deviceSelectors?: [...#NetworkDeviceSelector] @go(BondDeviceSelectors,[]NetworkDeviceSelector)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	//     Not supported at the moment.
	arpIPTarget?: [...string] @go(BondARPIPTarget,[]string)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	mode: string @go(BondMode)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	xmitHashPolicy?: string @go(BondHashPolicy)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	lacpRate?: string @go(BondLACPRate)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	//     Not supported at the moment.
	adActorSystem?: string @go(BondADActorSystem)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	arpValidate?: string @go(BondARPValidate)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	arpAllTargets?: string @go(BondARPAllTargets)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	primary?: string @go(BondPrimary)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	primaryReselect?: string @go(BondPrimaryReselect)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	failOverMac?: string @go(BondFailOverMac)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	adSelect?: string @go(BondADSelect)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	miimon?: uint32 @go(BondMIIMon)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	updelay?: uint32 @go(BondUpDelay)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	downdelay?: uint32 @go(BondDownDelay)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	arpInterval?: uint32 @go(BondARPInterval)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	resendIgmp?: uint32 @go(BondResendIGMP)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	minLinks?: uint32 @go(BondMinLinks)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	lpInterval?: uint32 @go(BondLPInterval)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	packetsPerSlave?: uint32 @go(BondPacketsPerSlave)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	numPeerNotif?: uint8 @go(BondNumPeerNotif)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	tlbDynamicLb?: uint8 @go(BondTLBDynamicLB)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	allSlavesActive?: uint8 @go(BondAllSlavesActive)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	useCarrier?: null | bool @go(BondUseCarrier,*bool)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	adActorSysPrio?: uint16 @go(BondADActorSysPrio)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	adUserPortKey?: uint16 @go(BondADUserPortKey)

	//   description: |
	//     A bond option.
	//     Please see the official kernel documentation.
	peerNotifyDelay?: uint32 @go(BondPeerNotifyDelay)
}

// STP contains the various options for configuring the STP properties of a bridge interface.
#STP: {
	//   description: Whether Spanning Tree Protocol (STP) is enabled.
	enabled?: null | bool @go(STPEnabled,*bool)
}

// Bridge contains the various options for configuring a bridge interface.
#Bridge: {
	//   description: The interfaces that make up the bridge.
	interfaces: [...string] @go(BridgedInterfaces,[]string)

	//   description: |
	//     A bridge option.
	//     Please see the official kernel documentation.
	stp?: null | #STP @go(BridgeSTP,*STP)
}

// VlanList is a list of *Vlan structures with overridden merge process.
//
//docgen:alias
#VlanList: [...null | #Vlan]

// Vlan represents vlan settings for a device.
#Vlan: {
	//   description: The addresses in CIDR notation or as plain IPs to use.
	addresses?: [...string] @go(VlanAddresses,[]string)

	// docgen:nodoc
	cidr?: string @go(VlanCIDR)

	//   description: A list of routes associated with the VLAN.
	routes: [...null | #Route] @go(VlanRoutes,[]*Route)

	//   description: Indicates if DHCP should be used.
	dhcp?: null | bool @go(VlanDHCP,*bool)

	//   description: The VLAN's ID.
	vlanId: uint16 @go(VlanID)

	//   description: The VLAN's MTU.
	mtu?: uint32 @go(VlanMTU)

	//   description: The VLAN's virtual IP address configuration.
	vip?: null | #DeviceVIPConfig @go(VlanVIP,*DeviceVIPConfig)

	//   description: |
	//     DHCP specific options.
	//     `dhcp` *must* be set to true for these to take effect.
	dhcpOptions?: null | #DHCPOptions @go(VlanDHCPOptions,*DHCPOptions)
}

// Route represents a network route.
#Route: {
	//   description: The route's network (destination).
	network: string @go(RouteNetwork)

	//   description: The route's gateway (if empty, creates link scope route).
	gateway: string @go(RouteGateway)

	//   description: The route's source address (optional).
	source?: string @go(RouteSource)

	//   description: The optional metric for the route.
	metric?: uint32 @go(RouteMetric)

	//   description: The optional MTU for the route.
	mtu?: uint32 @go(RouteMTU)
}

// RegistryMirrorConfig represents mirror configuration for a registry.
#RegistryMirrorConfig: {
	//   description: |
	//     List of endpoints (URLs) for registry mirrors to use.
	//     Endpoint configures HTTP/HTTPS access mode, host name,
	//     port and path (if path is not set, it defaults to `/v2`).
	endpoints: [...string] @go(MirrorEndpoints,[]string)

	//   description: |
	//     Use the exact path specified for the endpoint (don't append /v2/).
	//     This setting is often required for setting up multiple mirrors
	//     on a single instance of a registry.
	overridePath?: null | bool @go(MirrorOverridePath,*bool)
}

// RegistryConfig specifies auth & TLS config per registry.
#RegistryConfig: {
	//   description: |
	//     The TLS configuration for the registry.
	//   examples:
	//     - value: machineConfigRegistryTLSConfigExample1()
	//     - value: machineConfigRegistryTLSConfigExample2()
	tls?: null | #RegistryTLSConfig @go(RegistryTLS,*RegistryTLSConfig)

	//   description: |
	//     The auth configuration for this registry.
	//     Note: changes to the registry auth will not be picked up by the CRI containerd plugin without a reboot.
	//   examples:
	//     - value: machineConfigRegistryAuthConfigExample()
	auth?: null | #RegistryAuthConfig @go(RegistryAuth,*RegistryAuthConfig)
}

// RegistryAuthConfig specifies authentication configuration for a registry.
#RegistryAuthConfig: {
	//   description: |
	//     Optional registry authentication.
	//     The meaning of each field is the same with the corresponding field in [`.docker/config.json`](https://docs.docker.com/engine/api/v1.41/#section/Authentication).
	username?: string @go(RegistryUsername)

	//   description: |
	//     Optional registry authentication.
	//     The meaning of each field is the same with the corresponding field in [`.docker/config.json`](https://docs.docker.com/engine/api/v1.41/#section/Authentication).
	password?: string @go(RegistryPassword)

	//   description: |
	//     Optional registry authentication.
	//     The meaning of each field is the same with the corresponding field in [`.docker/config.json`](https://docs.docker.com/engine/api/v1.41/#section/Authentication).
	auth?: string @go(RegistryAuth)

	//   description: |
	//     Optional registry authentication.
	//     The meaning of each field is the same with the corresponding field in [`.docker/config.json`](https://docs.docker.com/engine/api/v1.41/#section/Authentication).
	identityToken?: string @go(RegistryIdentityToken)
}

// RegistryTLSConfig specifies TLS config for HTTPS registries.
#RegistryTLSConfig: {
	//   description: |
	//     CA registry certificate to add the list of trusted certificates.
	//     Certificate should be base64-encoded.
	//   schema:
	//     type: string
	ca?: #Base64Bytes @go(TLSCA)

	//   description: |
	//     Skip TLS server certificate verification (not recommended).
	insecureSkipVerify?: null | bool @go(TLSInsecureSkipVerify,*bool)
}

// SystemDiskEncryptionConfig specifies system disk partitions encryption settings.
#SystemDiskEncryptionConfig: {
	//   description: |
	//     State partition encryption.
	state?: null | #EncryptionConfig @go(StatePartition,*EncryptionConfig)

	//   description: |
	//     Ephemeral partition encryption.
	ephemeral?: null | #EncryptionConfig @go(EphemeralPartition,*EncryptionConfig)
}

// FeaturesConfig describes individual Talos features that can be switched on or off.
#FeaturesConfig: {
	//   description: |
	//     Enable role-based access control (RBAC).
	rbac?: null | bool @go(RBAC,*bool)

	//   description: |
	//     Enable stable default hostname.
	stableHostname?: null | bool @go(StableHostname,*bool)

	//   description: |
	//    Configure Talos API access from Kubernetes pods.
	//
	//    This feature is disabled if the feature config is not specified.
	//   examples:
	//     - value: kubernetesTalosAPIAccessConfigExample()
	kubernetesTalosAPIAccess?: null | #KubernetesTalosAPIAccessConfig @go(KubernetesTalosAPIAccessConfig,*KubernetesTalosAPIAccessConfig)

	//   description: |
	//     Enable checks for extended key usage of client certificates in apid.
	apidCheckExtKeyUsage?: null | bool @go(ApidCheckExtKeyUsage,*bool)

	//   description: |
	//     Enable XFS project quota support for EPHEMERAL partition and user disks.
	//     Also enables kubelet tracking of ephemeral disk usage in the kubelet via quota.
	diskQuotaSupport?: null | bool @go(DiskQuotaSupport,*bool)

	//   description: |
	//     KubePrism - local proxy/load balancer on defined port that will distribute
	//     requests to all API servers in the cluster.
	kubePrism?: null | #KubePrism @go(KubePrismSupport,*KubePrism)

	//   description: |
	//     Configures host DNS caching resolver.
	hostDNS?: null | #HostDNSConfig @go(HostDNSSupport,*HostDNSConfig)
}

// KubePrism describes the configuration for the KubePrism load balancer.
#KubePrism: {
	//   description: |
	//     Enable KubePrism support - will start local load balancing proxy.
	enabled?: null | bool @go(ServerEnabled,*bool)

	//   description: |
	//     KubePrism port.
	port?: int @go(ServerPort)
}

// KubernetesTalosAPIAccessConfig describes the configuration for the Talos API access from Kubernetes pods.
#KubernetesTalosAPIAccessConfig: {
	//   description: |
	//     Enable Talos API access from Kubernetes pods.
	enabled?: null | bool @go(AccessEnabled,*bool)

	//   description: |
	//     The list of Talos API roles which can be granted for access from Kubernetes pods.
	//
	//     Empty list means that no roles can be granted, so access is blocked.
	allowedRoles?: [...string] @go(AccessAllowedRoles,[]string)

	//   description: |
	//     The list of Kubernetes namespaces Talos API access is available from.
	allowedKubernetesNamespaces?: [...string] @go(AccessAllowedKubernetesNamespaces,[]string)
}

// HostDNSConfig describes the configuration for the host DNS resolver.
#HostDNSConfig: {
	//   description: |
	//     Enable host DNS caching resolver.
	enabled?: null | bool @go(HostDNSEnabled,*bool)

	//   description: |
	//     Use the host DNS resolver as upstream for Kubernetes CoreDNS pods.
	//
	//     When enabled, CoreDNS pods use host DNS server as the upstream DNS (instead of
	//     using configured upstream DNS resolvers directly).
	forwardKubeDNSToHost?: null | bool @go(HostDNSForwardKubeDNSToHost,*bool)

	//   description: |
	//     Resolve member hostnames using the host DNS resolver.
	//
	//     When enabled, cluster member hostnames and node names are resolved using the host DNS resolver.
	//     This requires service discovery to be enabled.
	resolveMemberNames?: null | bool @go(HostDNSResolveMemberNames,*bool)
}

// VolumeMountConfig struct describes extra volume mount for the static pods.
#VolumeMountConfig: {
	//   description: |
	//     Path on the host.
	//   examples:
	//     - value: '"/var/lib/auth"'
	hostPath: string @go(VolumeHostPath)

	//   description: |
	//     Path in the container.
	//   examples:
	//     - value: '"/etc/kubernetes/auth"'
	mountPath: string @go(VolumeMountPath)

	//   description: |
	//     Mount the volume read only.
	//   examples:
	//     - value: true
	readonly?: bool @go(VolumeReadOnly)
}

// ClusterInlineManifests is a list of ClusterInlineManifest.
//
//docgen:alias
#ClusterInlineManifests: [...#ClusterInlineManifest]

// ClusterInlineManifest struct describes inline bootstrap manifests for the user.
#ClusterInlineManifest: {
	//   description: |
	//     Name of the manifest.
	//     Name should be unique.
	//   examples:
	//     - value: '"csi"'
	name: string @go(InlineManifestName)

	//   description: |
	//     Manifest contents as a string.
	//   examples:
	//     - value: '"/etc/kubernetes/auth"'
	contents: string @go(InlineManifestContents)
}

// NetworkKubeSpan struct describes KubeSpan configuration.
#NetworkKubeSpan: {
	// description: |
	//   Enable the KubeSpan feature.
	//   Cluster discovery should be enabled with .cluster.discovery.enabled for KubeSpan to be enabled.
	enabled?: null | bool @go(KubeSpanEnabled,*bool)

	// description: |
	//   Control whether Kubernetes pod CIDRs are announced over KubeSpan from the node.
	//   If disabled, CNI handles encapsulating pod-to-pod traffic into some node-to-node tunnel,
	//   and KubeSpan handles the node-to-node traffic.
	//   If enabled, KubeSpan will take over pod-to-pod traffic and send it over KubeSpan directly.
	//   When enabled, KubeSpan should have a way to detect complete pod CIDRs of the node which
	//   is not always the case with CNIs not relying on Kubernetes for IPAM.
	advertiseKubernetesNetworks?: null | bool @go(KubeSpanAdvertiseKubernetesNetworks,*bool)

	// description: |
	//   Skip sending traffic via KubeSpan if the peer connection state is not up.
	//   This provides configurable choice between connectivity and security: either traffic is always
	//   forced to go via KubeSpan (even if Wireguard peer connection is not up), or traffic can go directly
	//   to the peer if Wireguard connection can't be established.
	allowDownPeerBypass?: null | bool @go(KubeSpanAllowDownPeerBypass,*bool)

	// description: |
	//   KubeSpan can collect and publish extra endpoints for each member of the cluster
	//   based on Wireguard endpoint information for each peer.
	//   This feature is disabled by default, don't enable it
	//   with high number of peers (>50) in the KubeSpan network (performance issues).
	harvestExtraEndpoints?: null | bool @go(KubeSpanHarvestExtraEndpoints,*bool)

	// description: |
	//   KubeSpan link MTU size.
	//   Default value is 1420.
	mtu?: null | uint32 @go(KubeSpanMTU,*uint32)

	// description: |
	//   KubeSpan advanced filtering of network addresses .
	//
	//   Settings in this section are optional, and settings apply only to the node.
	filters?: null | #KubeSpanFilters @go(KubeSpanFilters,*KubeSpanFilters)
}

// KubeSpanFilters struct describes KubeSpan advanced network addresses filtering.
#KubeSpanFilters: {
	// description: |
	//   Filter node addresses which will be advertised as KubeSpan endpoints for peer-to-peer Wireguard connections.
	//
	//   By default, all addresses are advertised, and KubeSpan cycles through all endpoints until it finds one that works.
	//
	//   Default value: no filtering.
	// examples:
	//   - name: Exclude addresses in 192.168.0.0/16 subnet.
	//     value: '[]string{"0.0.0.0/0", "!192.168.0.0/16", "::/0"}'
	endpoints?: [...string] @go(KubeSpanFiltersEndpoints,[]string)
}

// NetworkDeviceSelector struct describes network device selector.
#NetworkDeviceSelector: {
	// description: PCI, USB bus prefix, supports matching by wildcard.
	busPath?: string @go(NetworkDeviceBus)

	// description: Device hardware address, supports matching by wildcard.
	hardwareAddr?: string @go(NetworkDeviceHardwareAddress)

	// description: PCI ID (vendor ID, product ID), supports matching by wildcard.
	pciID?: string @go(NetworkDevicePCIID)

	// description: Kernel driver, supports matching by wildcard.
	driver?: string @go(NetworkDeviceKernelDriver)

	// description: Select only physical devices.
	physical?: null | bool @go(NetworkDevicePhysical,*bool)
}

// ClusterDiscoveryConfig struct configures cluster membership discovery.
#ClusterDiscoveryConfig: {
	// description: |
	//   Enable the cluster membership discovery feature.
	//   Cluster discovery is based on individual registries which are configured under the registries field.
	enabled?: null | bool @go(DiscoveryEnabled,*bool)

	// description: |
	//   Configure registries used for cluster member discovery.
	registries: #DiscoveryRegistriesConfig @go(DiscoveryRegistries)
}

// DiscoveryRegistriesConfig struct configures cluster membership discovery.
#DiscoveryRegistriesConfig: {
	// description: |
	//   Kubernetes registry uses Kubernetes API server to discover cluster members and stores additional information
	//   as annotations on the Node resources.
	kubernetes: #RegistryKubernetesConfig @go(RegistryKubernetes)

	// description: |
	//   Service registry is using an external service to push and pull information about cluster members.
	service: #RegistryServiceConfig @go(RegistryService)
}

// RegistryKubernetesConfig struct configures Kubernetes discovery registry.
#RegistryKubernetesConfig: {
	// description: |
	//   Disable Kubernetes discovery registry.
	disabled?: null | bool @go(RegistryDisabled,*bool)
}

// RegistryServiceConfig struct configures Kubernetes discovery registry.
#RegistryServiceConfig: {
	// description: |
	//   Disable external service discovery registry.
	disabled?: null | bool @go(RegistryDisabled,*bool)

	// description: |
	//   External service endpoint.
	// examples:
	//   - value: constants.DefaultDiscoveryServiceEndpoint
	endpoint?: string @go(RegistryEndpoint)
}

// UdevConfig describes how the udev system should be configured.
#UdevConfig: {
	//   description: |
	//     List of udev rules to apply to the udev system
	rules?: [...string] @go(UdevRules,[]string)
}

// LoggingConfig struct configures Talos logging.
#LoggingConfig: {
	// description: |
	//   Logging destination.
	destinations: [...#LoggingDestination] @go(LoggingDestinations,[]LoggingDestination)
}

// LoggingDestination struct configures Talos logging destination.
#LoggingDestination: {
	// description: |
	//   Where to send logs. Supported protocols are "tcp" and "udp".
	// examples:
	//   - value: loggingEndpointExample1()
	//   - value: loggingEndpointExample2()
	endpoint?: null | #Endpoint @go(LoggingEndpoint,*Endpoint)

	// description: |
	//   Logs format.
	// values:
	//   - json_lines
	format: string @go(LoggingFormat)

	// description: |
	//   Extra tags (key-value) pairs to attach to every log message sent.
	extraTags?: {[string]: string} @go(LoggingExtraTags,map[string]string)
}

// KernelConfig struct configures Talos Linux kernel.
#KernelConfig: {
	// description: |
	//   Kernel modules to load.
	modules?: [...null | #KernelModuleConfig] @go(KernelModules,[]*KernelModuleConfig)
}

// KernelModuleConfig struct configures Linux kernel modules to load.
#KernelModuleConfig: {
	// description: |
	//   Module name.
	name: string @go(ModuleName)

	// description: |
	//   Module parameters, changes applied after reboot.
	parameters?: [...string] @go(ModuleParameters,[]string)
}
